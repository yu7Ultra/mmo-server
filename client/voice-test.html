<!DOCTYPE html>
<html>
<head>
  <title>MMO Voice / Audio åŠŸèƒ½æµ‹è¯•</title>
  <meta charset="UTF-8" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; padding: 18px; background:#121212; color:#e2e2e2; }
    h1 { color:#4CAF50; margin:0 0 12px; }
    h2 { color:#2196F3; margin:10px 0; font-size:18px; }
    .section { background:#1e1e1e; border:1px solid #333; border-radius:6px; padding:14px; margin-bottom:14px; }
    button { background:#2d7d46; color:#fff; border:none; border-radius:4px; padding:6px 12px; cursor:pointer; font-size:13px; }
    button:hover { background:#2b6f40; }
    button:disabled { background:#444; cursor:not-allowed; }
    input, select { font-size:13px; }
    .channel { border:1px solid #444; background:#262626; border-radius:4px; padding:8px; margin:6px 0; }
    .member { font-size:12px; line-height:16px; }
    .member.muted { opacity:.6; }
    #status { padding:8px 12px; border-radius:4px; background:#2f2f2f; font-size:14px; }
    .log { font-family:monospace; font-size:11px; background:#111; border:1px solid #222; padding:8px; height:220px; overflow-y:auto; }
    .log-entry { padding:2px 0; border-bottom:1px solid #1f1f1f; }
    .error { color:#ff5252; }
    .success { color:#4CAF50; }
    .info { color:#64b5f6; }
    .meter {position:relative;width:160px;height:10px;background:#222;border:1px solid #444;border-radius:3px;overflow:hidden;}
    .meter .fill {position:absolute;left:0;top:0;height:100%;width:0;background:linear-gradient(90deg,#2ecc71,#f1c40f,#e67e22,#e74c3c);} 
    #vad-indicator { transition:.15s background,color; }
    .member.speaking { background:#203820; border-left:3px solid #2ecc71; }
  </style>
</head>
<body>
  <h1>ğŸ™ï¸ MMO Voice / Audio åŠŸèƒ½æµ‹è¯•</h1>
  <div id="status">Disconnected</div>
  <div id="device-status" style="margin:6px 0 14px;font-size:12px;color:#bbb;">è®¾å¤‡æšä¸¾ä¸­...</div>

  <div class="section">
    <h2>è¿æ¥ (Colyseus)</h2>
    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
      <label>WS URL: <input id="ws-url" value="ws://192.168.1.46:2567" style="width:180px;background:#181818;color:#eee;border:1px solid #444;padding:4px;border-radius:4px;"/></label>
      <label>æˆ¿é—´: <input id="room-name" value="my_room" style="width:120px;background:#181818;color:#eee;border:1px solid #444;padding:4px;border-radius:4px;"/></label>
      <button id="connect-btn" onclick="connect()">Connect</button>
      <button id="disconnect-btn" onclick="disconnect()" disabled>Disconnect</button>
    </div>
  </div>

  <div class="section">
    <h2>é¢‘é“æ“ä½œ</h2>
    <div style="display:flex;flex-wrap:wrap;gap:8px;">
      <button onclick="joinGlobal()">åŠ å…¥ Global</button>
      <input id="new-channel-name" placeholder="æ–°é¢‘é“åç§°" style="background:#181818;color:#eee;border:1px solid #444;padding:4px;border-radius:4px;width:160px;"/>
      <button onclick="createTeam()">åˆ›å»ºé¢‘é“</button>
      <button onclick="leaveVoice()">ç¦»å¼€é¢‘é“</button>
    </div>
  </div>

  <div class="section">
    <h2>æœ¬åœ°éŸ³é¢‘æ§åˆ¶</h2>
    <div style="display:flex;flex-wrap:wrap;gap:8px;">
      <label>è¾“å…¥è®¾å¤‡: <select id="input-device" style="background:#181818;color:#eee;border:1px solid #444;padding:4px;border-radius:4px;min-width:180px;"></select></label>
      <label>è¾“å‡ºè®¾å¤‡: <select id="output-device" style="background:#181818;color:#eee;border:1px solid #444;padding:4px;border-radius:4px;min-width:180px;"></select></label>
      <button onclick="refreshDevices()">åˆ·æ–°è®¾å¤‡</button>
      <button onclick="applyInputDevice()">åº”ç”¨è¾“å…¥</button>
      <button onclick="toggleMute()">é™éŸ³</button>
      <button onclick="toggleDeafen()">è€³è‹</button>
      <button onclick="toggleLoopback()">æœ¬åœ°å›å£°</button>
      <button onclick="startRecord()" id="record-btn">å¼€å§‹å½•éŸ³</button>
      <button onclick="downloadRecord()" id="download-btn" disabled>ä¸‹è½½å½•éŸ³</button>
    </div>
    <div style="margin-top:10px;display:flex;flex-direction:column;gap:8px;">
      <div style="display:flex;align-items:center;gap:6px;">
        <span style="font-size:12px;color:#aaa;">è¾“å…¥ç”µå¹³</span>
        <div class="meter"><div class="fill" id="input-fill"></div></div>
        <span id="input-level-text" style="font-size:11px;width:42px;">0%</span>
        <span id="vad-indicator" style="font-size:11px;padding:2px 8px;background:#333;border-radius:3px;">VAD: é™éŸ³</span>
      </div>
      <div style="display:flex;align-items:center;gap:6px;">
        <span style="font-size:12px;color:#aaa;">è¿œç«¯æ··åˆç”µå¹³</span>
        <div class="meter"><div class="fill" id="remote-fill"></div></div>
        <span id="remote-level-text" style="font-size:11px;width:42px;">0%</span>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>é¢‘é“åˆ—è¡¨</h2>
    <div id="channels">No channels</div>
  </div>

  <div class="section">
    <h2>æˆ‘çš„çŠ¶æ€</h2>
    <div id="myStatus">Not in voice</div>
    <div id="rtc-stats" style="font-size:11px;color:#aaa;margin-top:8px;">Stats: -</div>
  </div>

  <div class="section">
    <h2>è°ƒè¯•æ—¥å¿—</h2>
    <div id="log" class="log"></div>
  </div>

  <script src="https://unpkg.com/colyseus.js@^0.16.0/dist/colyseus.js"></script>
  <script>
    let room = null;
    let localStream = null;
    const peerConnections = new Map();
    let isMuted = false;
    let isDeafened = false;
    let audioContext = null;
    let analyserInput = null, analyserRemote = null;
    let inputData = null, remoteData = null;
    let meterRAF = null;
    let recordingChunks = [];
    let mediaRecorder = null;
    let vadLastActive = 0;
    const VAD_THRESHOLD = 0.05;
    let statsInterval = null;
    let loopbackAudio = null;
  // Per-peer audio activity tracking
  const remoteAnalysers = new Map(); // peerId -> { analyser, data, lastActive, speaking }
  const speakingPeers = new Set(); // sessionIds currently speaking (local + remote)

    const rtcConfig = { iceServers: [ { urls:'stun:stun.l.google.com:19302' }, { urls:'stun:stun1.l.google.com:19302' } ] };

    function log(message, type='info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry); logDiv.scrollTop = logDiv.scrollHeight; console[type==='error'?'error':'log'](message);
    }

    async function connect() {
      try {
        const wsUrl = document.getElementById('ws-url').value.trim();
        const roomName = document.getElementById('room-name').value.trim();
        log(`Connecting ${wsUrl} room=${roomName} ...`);
        const client = new Colyseus.Client(wsUrl);
        room = await client.joinOrCreate(roomName, { name: 'VoiceUser_'+Math.floor(Math.random()*1000) });
        document.getElementById('status').textContent = 'Connected: '+room.id;
        document.getElementById('status').style.background = '#1b5e20';
        document.getElementById('connect-btn').disabled = true;
        document.getElementById('disconnect-btn').disabled = false;
  // Some environments may briefly have an undefined room.id; guard for that.
  log('Room joined '+(room.id || '(no-id-yet)'),'success');
        setupVoiceListeners();
        await initDevicesAndStream();
        startStatsLoop();
      } catch (err) {
        log('Connection error: '+ err.message,'error');
      }
    }

    function disconnect() {
      if (!room) return;
      log('Disconnecting...');
      peerConnections.forEach((_, id)=>closePeerConnection(id)); peerConnections.clear();
      if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream=null; }
      try { room.leave(); } catch(_){}
      room = null;
      if (statsInterval) { clearInterval(statsInterval); statsInterval=null; }
      stopMeters();
      document.getElementById('status').textContent='Disconnected';
      document.getElementById('status').style.background='#512222';
      document.getElementById('connect-btn').disabled=false;
      document.getElementById('disconnect-btn').disabled=true;
      document.getElementById('channels').innerHTML='No channels';
      document.getElementById('myStatus').textContent='Not in voice';
      document.getElementById('rtc-stats').textContent='Stats: -';
      log('Disconnected','info');
    }

    async function initDevicesAndStream() {
      await refreshDevices();
      const deviceId = document.getElementById('input-device').value;
      try {
        log('Request mic device='+deviceId);
        localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: deviceId?{ exact: deviceId }:undefined, echoCancellation:true, noiseSuppression:true, autoGainControl:true } });
        log('Microphone access granted','success');
        setupAudioContext();
      } catch (e) { log('Microphone error: '+e.message,'error'); alert('éº¦å…‹é£è®¿é—®å¤±è´¥: '+e.message); }
    }

    async function applyInputDevice() {
      // å¦‚æœè¿˜æ²¡è¿æ¥æˆ–æ²¡æœ‰è®¾å¤‡é€‰é¡¹ï¼Œç›´æ¥è¿”å›
      const deviceId = document.getElementById('input-device').value;
      if (!deviceId) { log('No input device selected','error'); return; }
      if (mediaRecorder) stopRecord();
      // ä¸åœæ­¢æ•´ä¸ª AudioContextï¼Œåªæ›¿æ¢è¾“å…¥æµ
      if (localStream) {
        localStream.getTracks().forEach(t=>t.stop());
      }
      localStream = null;
      analyserInput = null; inputData = null;
      // ä¿æŒè¿œç«¯åˆ†æå™¨ä¸å˜ï¼›åªé‡å»ºæœ¬åœ°è¾“å…¥åˆ†æå™¨
      try {
        log('Re-applying mic device='+deviceId);
        localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: deviceId }, echoCancellation:true, noiseSuppression:true, autoGainControl:true } });
        // è‹¥å·²æœ‰ audioContext ç›´æ¥å¤ç”¨ï¼Œå¦åˆ™åˆ›å»º
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioContext.state === 'suspended') {
          // æŸäº›æµè§ˆå™¨åœ¨å¤šæ¬¡è°ƒç”¨åä¼šæŒ‚èµ·
          try { await audioContext.resume(); } catch(_) {}
        }
        const source = audioContext.createMediaStreamSource(localStream);
        analyserInput = audioContext.createAnalyser(); analyserInput.fftSize=512; source.connect(analyserInput); inputData = new Uint8Array(analyserInput.frequencyBinCount);
        // é‡å¯æœ¬åœ°ç”µå¹³åŠ¨ç”»ï¼ˆå¦‚æœä¹‹å‰å·²åœ¨è¿è¡Œï¼Œè¿™é‡Œä¸ä¼šé‡å¤å¯åŠ¨ï¼‰
        if (!meterRAF) startMeters();
        // æ›´æ–°æ‰€æœ‰ç°æœ‰ peer çš„å‘é€ track (ä¸å¼ºåˆ¶é‡å»ºè¿æ¥ï¼Œé™ä½è´Ÿè½½)
        peerConnections.forEach((pc, peerId)=>{
          // ç§»é™¤æ—§çš„å‘é€è½¨é“; ç®€åŒ–å¤„ç†ï¼šå…³é—­æ—§ senderï¼Œé‡æ–° addTrack
          const senders = pc.getSenders();
          senders.forEach(s=>{ if(s.track && s.track.kind==='audio') { try { pc.removeTrack(s); } catch(_){} } });
          localStream.getTracks().forEach(t=> pc.addTrack(t, localStream));
          log('Updated track for peer '+peerId);
        });
        log('Mic reapplied successfully','success');
      } catch (e) {
        log('Reapply mic error: '+e.message,'error');
      }
      updateMyStatus();
    }

    async function refreshDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const inputSel = document.getElementById('input-device');
        const outputSel = document.getElementById('output-device');
        inputSel.innerHTML=''; outputSel.innerHTML='';
        let sinkSupported = typeof HTMLMediaElement.prototype.setSinkId === 'function';
        devices.forEach(d=>{ const opt=document.createElement('option'); opt.value=d.deviceId; opt.textContent=`[${d.kind}] ${d.label||d.deviceId}`; if(d.kind==='audioinput') inputSel.appendChild(opt); if(d.kind==='audiooutput') outputSel.appendChild(opt); });
        document.getElementById('device-status').textContent = `è¾“å…¥è®¾å¤‡:${inputSel.length} è¾“å‡ºè®¾å¤‡:${outputSel.length}${sinkSupported?'':' (æµè§ˆå™¨ä¸æ”¯æŒè¾“å‡ºåˆ‡æ¢)'}`;
      } catch (e) { document.getElementById('device-status').textContent='è®¾å¤‡æšä¸¾å¤±è´¥: '+e.message; }
    }

    function setupAudioContext() {
      if (audioContext) return;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(localStream);
      analyserInput = audioContext.createAnalyser(); analyserInput.fftSize=512; source.connect(analyserInput); inputData = new Uint8Array(analyserInput.frequencyBinCount);
      startMeters();
    }

    function startMeters() { if (meterRAF) return; const loop=()=>{ updateInputMeter(); updateRemoteMeter(); meterRAF=requestAnimationFrame(loop); }; loop(); }
    function stopMeters(){ if(meterRAF) cancelAnimationFrame(meterRAF); meterRAF=null; }
  function updateInputMeter(){ if(!analyserInput||!inputData) return; analyserInput.getByteTimeDomainData(inputData); let sum=0; for(let i=0;i<inputData.length;i++){const v=(inputData[i]-128)/128; sum+=v*v;} const rms=Math.sqrt(sum/inputData.length); const scaled=Math.min(1,rms*4); setMeter('input', scaled); if(scaled>VAD_THRESHOLD) vadLastActive=performance.now(); const speakingNow = performance.now()-vadLastActive<700; const wasSpeaking = speakingPeers.has(room?.sessionId); if(speakingNow && !wasSpeaking){ speakingPeers.add(room.sessionId); updateChannelDisplay(); } else if(!speakingNow && wasSpeaking){ speakingPeers.delete(room.sessionId); updateChannelDisplay(); } const vad=document.getElementById('vad-indicator'); if(speakingNow){ vad.textContent='VAD: è®²è¯ä¸­'; vad.style.background='#2e7d32'; } else { vad.textContent='VAD: é™éŸ³'; vad.style.background='#333'; } }
  function updateRemoteMeter(){ if(!analyserRemote||!remoteData) return; analyserRemote.getByteTimeDomainData(remoteData); let sum=0; for(let i=0;i<remoteData.length;i++){const v=(remoteData[i]-128)/128; sum+=v*v;} const rms=Math.sqrt(sum/remoteData.length); setMeter('remote', Math.min(1,rms*4)); updateRemotePeerActivity(); }
  function updateRemotePeerActivity(){ const now=performance.now(); remoteAnalysers.forEach((obj, peerId)=>{ obj.analyser.getByteTimeDomainData(obj.data); let sum=0; for(let i=0;i<obj.data.length;i++){ const v=(obj.data[i]-128)/128; sum+=v*v; } const rms=Math.sqrt(sum/obj.data.length); if(rms*4 > VAD_THRESHOLD) obj.lastActive=now; const speakingNow = (now - obj.lastActive) < 700; if(speakingNow && !obj.speaking){ obj.speaking=true; speakingPeers.add(peerId); updateChannelDisplay(); } else if(!speakingNow && obj.speaking){ obj.speaking=false; speakingPeers.delete(peerId); updateChannelDisplay(); } }); }
    function setMeter(which, level){ const fill=document.getElementById(which+'-fill'); const txt=document.getElementById(which+'-level-text'); if(!fill||!txt)return; fill.style.width=(level*100).toFixed(1)+'%'; txt.textContent=Math.round(level*100)+'%'; fill.style.filter= level>0.75?'brightness(1.25)':level>0.4?'brightness(1.0)':'brightness(.7)'; }

  function attachRemoteTrack(stream){ if(!audioContext) setupAudioContext(); if(audioContext && !analyserRemote){ const rsrc=audioContext.createMediaStreamSource(stream); analyserRemote=audioContext.createAnalyser(); analyserRemote.fftSize=512; rsrc.connect(analyserRemote); remoteData=new Uint8Array(analyserRemote.frequencyBinCount); } }
  function attachRemotePeerTrack(peerId, stream){ if(!audioContext) setupAudioContext(); const source = audioContext.createMediaStreamSource(stream); const analyser = audioContext.createAnalyser(); analyser.fftSize=512; source.connect(analyser); const data = new Uint8Array(analyser.frequencyBinCount); remoteAnalysers.set(peerId,{ analyser, data, lastActive:0, speaking:false }); }

    function toggleLoopback(){ if(!localStream){ log('No local stream','error'); return;} if(loopbackAudio){ loopbackAudio.srcObject=null; loopbackAudio.remove(); loopbackAudio=null; log('Loopback disabled'); } else { loopbackAudio=document.createElement('audio'); loopbackAudio.autoplay=true; loopbackAudio.muted=false; loopbackAudio.srcObject=localStream; document.body.appendChild(loopbackAudio); log('Loopback enabled','success'); } }

    function startRecord(){ if(!localStream){ log('Cannot record: no stream','error'); return;} if(mediaRecorder){ log('Already recording','info'); return;} mediaRecorder=new MediaRecorder(localStream,{mimeType:'audio/webm'}); recordingChunks=[]; mediaRecorder.ondataavailable=e=>{if(e.data.size>0) recordingChunks.push(e.data);}; mediaRecorder.onstop=()=>{ document.getElementById('download-btn').disabled= recordingChunks.length===0; }; mediaRecorder.start(); document.getElementById('record-btn').textContent='åœæ­¢å½•éŸ³'; document.getElementById('record-btn').onclick=stopRecord; log('Recording started','success'); }
    function stopRecord(){ if(!mediaRecorder) return; mediaRecorder.stop(); log('Recording stopped'); document.getElementById('record-btn').textContent='å¼€å§‹å½•éŸ³'; document.getElementById('record-btn').onclick=startRecord; mediaRecorder=null; }
    function downloadRecord(){ if(!recordingChunks.length) return; const blob=new Blob(recordingChunks,{type:'audio/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='voice_test_'+Date.now()+'.webm'; a.click(); URL.revokeObjectURL(url); }

    function setupVoiceListeners() {
      const $$ = Colyseus.getStateCallbacks(room);
      // Channels added
      $$(room.state).voiceChannels.onAdd((channel, channelId)=>{
        log(`Channel added: ${channel.name}`,'success');
        updateChannelDisplay();
        // Members add/remove
        $$(channel).members.onAdd((member,sid)=>{
          log(`Member joined ${channel.name}: ${member.playerName}`);
          updateChannelDisplay();
          const me = room.state.players.get(room.sessionId);
          if (sid!==room.sessionId && me?.currentVoiceChannel === channelId) {
            setupPeerConnection(sid);
          }
        });
        $$(channel).members.onRemove((member,sid)=>{
          log(`Member left ${channel.name}: ${member.playerName}`);
          updateChannelDisplay();
          closePeerConnection(sid);
        });
      });
      $$(room.state).voiceChannels.onRemove((channel)=>{ log(`Channel removed: ${channel.name}`); updateChannelDisplay(); });

      // Players added
      $$(room.state).players.onAdd((player,sid)=>{
        if (sid === room.sessionId) {
          // Listen to voice fields changes for status panel
          $$(player).listen('currentVoiceChannel', updateMyStatus);
          $$(player).listen('voiceMuted', updateMyStatus);
          $$(player).listen('voiceDeafened', updateMyStatus);
        }
        updateMyStatus();
      });
      $$(room.state).players.onRemove(()=> updateMyStatus());

      room.onMessage('voice:signal', (msg)=>{ log(`Signal ${msg.type} from ${msg.from}`); handleSignal(msg); });
      updateChannelDisplay();
    }

    function updateChannelDisplay(){
      const div = document.getElementById('channels');
      if (!room || !room.state || !room.state.voiceChannels) { div.innerHTML = 'No channels'; return; }
      let html = '';
      // Use MapSchema.forEach which supplies (value, key)
      try {
        room.state.voiceChannels.forEach((channel, channelId) => {
          if (!channel) return;
          const membersSchema = channel.members;
          let memberCount = 0;
          if (membersSchema && typeof membersSchema.forEach === 'function') {
            membersSchema.forEach(()=> memberCount++);
          } else if (membersSchema && membersSchema.size !== undefined) {
            memberCount = membersSchema.size;
          }
          html += `<div class=\"channel\"><strong>${channel.name || channelId}</strong> <span style=\"font-size:11px;color:#888\">(${channel.type || 'unknown'}) ${memberCount}/${channel.maxMembers || '?'} </span>`;
          if (membersSchema && typeof membersSchema.forEach === 'function') {
            membersSchema.forEach((m, mid) => {
              if (!m) return;
            const muteIcon = m.muted ? 'ğŸ”‡' : 'ğŸ¤';
            const deafIcon = m.deafened ? 'ğŸ™‰' : 'ğŸ‘‚';
            const isSpeaking = speakingPeers.has(m.sessionId) && !m.muted && !m.deafened;
            const speakIcon = isSpeaking ? 'ğŸŸ¢' : '';
            const clsBase = (m.muted || m.deafened) ? 'member muted' : 'member';
            const cls = isSpeaking ? clsBase + ' speaking' : clsBase;
            html += `<div class=\"${cls}\">${speakIcon} ${muteIcon} ${deafIcon} ${m.playerName || mid}</div>`;
            });
          }
          html += '</div>';
        });
      } catch (e) {
        console.warn('updateChannelDisplay error', e);
      }
      div.innerHTML = html || 'No channels';
    }

    function updateMyStatus(){ if(!room) return; const me=room.state.players.get(room.sessionId); const status=document.getElementById('myStatus'); if(!me){ status.textContent='Not in voice'; return;} if(me.currentVoiceChannel){ const ch=room.state.voiceChannels.get(me.currentVoiceChannel); const cname= ch? ch.name: me.currentVoiceChannel; status.innerHTML=`<div>é¢‘é“: <strong>${cname}</strong></div><div>${me.voiceMuted?'ğŸ”‡ Muted':'ğŸ¤ Unmuted'} | ${me.voiceDeafened?'ğŸ™‰ Deafened':'ğŸ‘‚ Hearing'}</div><div>Peers: ${peerConnections.size}</div>`; } else { status.textContent='Not in voice'; } }

  async function setupPeerConnection(peerId){ if(peerConnections.has(peerId)||!localStream) return; log('Create peer '+peerId); const pc=new RTCPeerConnection(rtcConfig); peerConnections.set(peerId, pc); localStream.getTracks().forEach(t=>pc.addTrack(t, localStream)); pc.ontrack=(ev)=>{ log('Remote track from '+peerId,'success'); const audio=document.createElement('audio'); audio.autoplay=true; audio.srcObject= ev.streams[0]; document.body.appendChild(audio); pc.remoteAudio=audio; attachRemoteTrack(ev.streams[0]); attachRemotePeerTrack(peerId, ev.streams[0]); }; pc.onicecandidate=(ev)=>{ if(ev.candidate) room.send('voice:signal',{ to:peerId, type:'ice-candidate', data:ev.candidate.toJSON() }); }; pc.onconnectionstatechange=()=>{ log('PC state '+peerId+': '+pc.connectionState); if(['failed','disconnected','closed'].includes(pc.connectionState)) closePeerConnection(peerId); }; const initiator = room.sessionId < peerId; if(initiator){ try { const offer= await pc.createOffer(); await pc.setLocalDescription(offer); room.send('voice:signal',{ to:peerId,type:'offer',data:offer }); log('Sent offer to '+peerId,'success'); } catch(e){ log('Offer error '+e.message,'error'); } } }

  async function handleSignal(msg){ const { from,type,data } = msg; let pc=peerConnections.get(from); const initiator = room.sessionId < from; if(type==='offer'){ if(initiator){ log('Glare: ignoring offer from '+from,'info'); return;} if(!pc){ pc=new RTCPeerConnection(rtcConfig); peerConnections.set(from, pc); if(localStream) localStream.getTracks().forEach(t=>pc.addTrack(t, localStream)); pc.ontrack=(ev)=>{ log('Remote track (offer path) from '+from,'success'); const audio=document.createElement('audio'); audio.autoplay=true; audio.srcObject=ev.streams[0]; document.body.appendChild(audio); pc.remoteAudio=audio; attachRemoteTrack(ev.streams[0]); attachRemotePeerTrack(from, ev.streams[0]); }; pc.onicecandidate=(ev)=>{ if(ev.candidate) room.send('voice:signal',{ to:from,type:'ice-candidate',data:ev.candidate.toJSON() }); }; }
      try { await pc.setRemoteDescription(new RTCSessionDescription(data)); const answer= await pc.createAnswer(); await pc.setLocalDescription(answer); room.send('voice:signal',{ to:from,type:'answer',data:answer }); log('Sent answer to '+from,'success'); } catch(e){ log('Answer error '+e.message,'error'); }
    } else if(type==='answer'){ try { await pc?.setRemoteDescription(new RTCSessionDescription(data)); log('Set remote answer from '+from,'success'); } catch(e){ log('Set answer error '+e.message,'error'); } } else if(type==='ice-candidate'){ try { await pc?.addIceCandidate(new RTCIceCandidate(data)); } catch(e){ log('ICE add error '+e.message,'error'); } } }

  function closePeerConnection(peerId){ const pc=peerConnections.get(peerId); if(!pc) return; if(pc.remoteAudio){ pc.remoteAudio.srcObject=null; pc.remoteAudio.remove(); } pc.close(); peerConnections.delete(peerId); remoteAnalysers.delete(peerId); if(speakingPeers.delete(peerId)) updateChannelDisplay(); log('Closed peer '+peerId); updateMyStatus(); }

    function joinGlobal(){ if(room){ room.send('voice:join',{ channelId:'global' }); log('Join global'); } }
    function createTeam(){ if(!room) return; const name = document.getElementById('new-channel-name').value.trim() || 'Team_'+Math.floor(Math.random()*1000); room.send('voice:create',{ name, type:'group', maxMembers:12 }); log('Create channel '+name); }
    function leaveVoice(){ if(!room) return; peerConnections.forEach((_,id)=>closePeerConnection(id)); peerConnections.clear(); room.send('voice:leave'); log('Left channel'); }
    function toggleMute(){ isMuted=!isMuted; if(localStream) localStream.getAudioTracks().forEach(t=>t.enabled=!isMuted); if(room) room.send('voice:mute',{ muted:isMuted }); log('Muted='+isMuted); updateMyStatus(); }
    function toggleDeafen(){ isDeafened=!isDeafened; peerConnections.forEach(pc=>{ if(pc.remoteAudio) pc.remoteAudio.muted=isDeafened; }); if(room) room.send('voice:deafen',{ deafened:isDeafened }); log('Deafened='+isDeafened); updateMyStatus(); }

    function startStatsLoop(){ if(statsInterval) return; statsInterval = setInterval(async ()=>{ try { let lines=[]; for(const [id, pc] of peerConnections){ const stats= await pc.getStats(); let audioIn=0, audioOut=0, rtt='-', packetsLost='-'; stats.forEach(r=>{ if(r.type==='inbound-rtp' && r.kind==='audio'){ audioIn=r.bytesReceived; packetsLost=r.packetsLost; rtt=r.roundTripTime||r.totalRoundTripTime||'-'; } if(r.type==='outbound-rtp' && r.kind==='audio'){ audioOut=r.bytesSent; } }); lines.push(`${id.substr(0,6)} in:${(audioIn/1024).toFixed(1)}KB out:${(audioOut/1024).toFixed(1)}KB rtt:${rtt} lost:${packetsLost}`); } document.getElementById('rtc-stats').textContent = 'Stats: '+(lines.length? lines.join(' | '):'-'); } catch(_){} }, 1500); }

    window.addEventListener('beforeunload', disconnect);
    window.downloadRecord=downloadRecord; window.startRecord=startRecord; window.stopRecord=stopRecord; window.toggleLoopback=toggleLoopback; window.refreshDevices=refreshDevices; window.applyInputDevice=applyInputDevice;
    refreshDevices();
  </script>
</body>
</html>
